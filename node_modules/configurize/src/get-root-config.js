import _ from 'lodash'
import fs from 'fs'
import path from 'path'

export function getConfig(vent) {
  let {module, file} = getConfigModule()
  const rootConf = parseConfig(module)
  vent.emit('root-config', rootConf, file)
  return rootConf || {}
}

function getConfigModule() {
  let file
  let module
  // TODO(vjpr): Check this don't break nothing!
  //   We might have to add it to webpack config.
  if (__CLIENT__) {
    // TODO(vjpr): This method is only for server-side.
    // file = getBrowserConfigPath()
    // module = require(file)
    module = require('configurize.browser.js')
  } else {
    file = getServerConfigPath()
    module = fs.existsSync(file) ? require(file) : null
  }
  return {file, module}
}

function parseConfig(module) {
  const opts = {}
  return _.isFunction(module) ? module(opts) : module
}

// TODO(vjpr): Use the strategy that webpackerator and babelator use for finding the config path.
export function getServerConfigPath() {

  const envPath = process.env.CONFIGURIZE_CONFIG_PATH
  if (_.get(process, 'versions.electron')) {
    // NOTE: require('app') will only exist in an Electron app.
    return envPath || path.join(require('app').getAppPath(), '.configurize.js')
  } else {
    const cwd = require('cwd')
    return envPath || cwd('.configurize.js')
  }

}

// NOTE: This is for server-side usage for generating our webpack config.
export function getBrowserConfigPath() {
  const cwd = require('cwd')
  return require.resolve(process.env.CONFIGURIZE_BROWSER_CONFIG_PATH || cwd('.configurize.browser.js'))
}
